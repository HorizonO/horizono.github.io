<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Horizon&#39;blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-02T11:47:33.629Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kyrie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于css预处理器</title>
    <link href="http://example.com/2020/11/29/cssPreprocessor/"/>
    <id>http://example.com/2020/11/29/cssPreprocessor/</id>
    <published>2020-11-29T02:31:59.000Z</published>
    <updated>2020-12-02T11:47:33.629Z</updated>
    
    <content type="html"><![CDATA[<p>最近逛招聘网站的时候，发现有很多公司要求需要使用less，sass，stylus的CSS预处理器。我马上去看了这三个CSS预处理器的在线文档，简单上手了一下。下面就简单的说一下CSS预处理器。</p><p>MDN是这样定义CSS预处理器的：CSS预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序。</p><h3 id="1-为什么会出现或者需要CSS预处理器呢？"><a href="#1-为什么会出现或者需要CSS预处理器呢？" class="headerlink" title="1.为什么会出现或者需要CSS预处理器呢？"></a>1.为什么会出现或者需要CSS预处理器呢？</h3><p>CSS（Cascading Style Sheet）被译为级联样式表，也称为风格样式表（style sheet），它主要是用来进行网页风格设计的，通过设置样式表，可以对HTML的标签进行样式编辑，能够进行初步的交互设计。但是，CSS本身而言，它并不是一种编程语言，它不像编程语言一样有自己的变量，常量或条件语句，只是一行行的属性描述，写起来费事而且难组织和维护。这个时候，就需要CSS预处理器的出现了。</p><p><strong>CSS预处理器</strong>是用一种专门的编程语言，进行web页面样式设计，然后编译成正常的CSS文件，以供项目使用。CSS预处理器还为CSS增加了一些编程的特性，无需考虑浏览器的兼容性问题。例如：可以在CSS中使用变量，函数等编程语言的特性来编写样式，可以<strong>让CSS更加简洁，适应性更强，可读性更佳，更易于代码的维护</strong>等诸多优点。</p><hr><p>未完待续……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近逛招聘网站的时候，发现有很多公司要求需要使用less，sass，stylus的CSS预处理器。我马上去看了这三个CSS预处理器的在线文档，简单上手了一下。下面就简单的说一下CSS预处理器。&lt;/p&gt;
&lt;p&gt;MDN是这样定义CSS预处理器的：CSS预处理器是一个能让你通过预</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>mac环境下Mongodb的安装与使用</title>
    <link href="http://example.com/2020/11/20/useMongodb/"/>
    <id>http://example.com/2020/11/20/useMongodb/</id>
    <published>2020-11-20T08:50:30.000Z</published>
    <updated>2020-11-20T11:36:54.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac下安装MongoDB"><a href="#Mac下安装MongoDB" class="headerlink" title="Mac下安装MongoDB"></a>Mac下安装MongoDB</h2><p>在mac下安装mongodb的方法有很多，例如：直接在mongodb官网下载压缩包或者使用brew命令下载等等。</p><h3 id="1-安装mongodb具体操作"><a href="#1-安装mongodb具体操作" class="headerlink" title="1.安装mongodb具体操作"></a>1.安装mongodb具体操作</h3><ul><li><p>我遇到的问题：</p><ul><li>brew命令安装失败，报错</li></ul><p><img src="http://ww1.sinaimg.cn/large/88b0c4d5gy1gkvucighf4j20ui0jo415.jpg" alt="brew命令安装出错"></p><p>原因：MongoDB不再是开源的了，并且已经从Homebrew中移除 #43770</p><p>解决方法：设定：<code>$ brew tap mongodb/brew</code>，然后再安装<code>brew install mongodb-community</code>即可</p></li></ul><p>  <img src="http://ww1.sinaimg.cn/large/88b0c4d5gy1gkvuf8kxc4j20ui0jo77o.jpg" alt="报错"></p><p>  原因：权限问题导致的</p><p>  解决方法：把权限收回，根据提示的目录收回</p><p>  <code>sudo chown -R whoam:admin /usr/local/share</code></p><ul><li>mongodb启动失败，报错</li></ul><p>“Shutting down”,”attr”:{“exitCode”:48}}</p><p>“Shutting down”,”attr”:{“exitCode”:100}}</p><p><img src="http://ww1.sinaimg.cn/large/88b0c4d5gy1gkvvc6wqh1j20vq0jogr1.jpg" alt="启动exitCode:100"></p><p>解决方法：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mac下安装MongoDB&quot;&gt;&lt;a href=&quot;#Mac下安装MongoDB&quot; class=&quot;headerlink&quot; title=&quot;Mac下安装MongoDB&quot;&gt;&lt;/a&gt;Mac下安装MongoDB&lt;/h2&gt;&lt;p&gt;在mac下安装mongodb的方法有很多，例如：直接</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="mongodb" scheme="http://example.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>前端面试——JS</title>
    <link href="http://example.com/2020/11/16/FE-interview-JS/"/>
    <id>http://example.com/2020/11/16/FE-interview-JS/</id>
    <published>2020-11-16T13:26:02.000Z</published>
    <updated>2020-11-28T08:00:45.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript面试基础"><a href="#JavaScript面试基础" class="headerlink" title="JavaScript面试基础"></a>JavaScript面试基础</h2><hr><h3 id="1-介绍js的基本数据类型"><a href="#1-介绍js的基本数据类型" class="headerlink" title="1.介绍js的基本数据类型"></a>1.介绍js的基本数据类型</h3><p>js一共有六种基本数据类型，分别是Undefined，null，boolean，number，string，还有ES6新增的Symbol和ES10中新增的BigInt类型。</p><p>Symbol代表创建后独一无二且不可变的数据类型，它的出现可能是为了解决可能出现的全局变量冲突的问题（个人观点）</p><p>BigInt是一种数字类型的数据，它可以表示任意精度格式的整数，使用BigInt可以安全地存储和操作大整数，即使这个数已经超出了Number能够表示的安全整数范围。</p><h3 id="2-JavaScript有几种类型的值？"><a href="#2-JavaScript有几种类型的值？" class="headerlink" title="2.JavaScript有几种类型的值？"></a>2.JavaScript有几种类型的值？</h3><p>JavaScript可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p><p>两种类型的主要区别是：存储位置不同</p><p><strong>原始数据类型</strong>直接存储在**<em>栈（stack）**</em>中的简单数据段，占据空间小，大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p><strong>引用数据类型</strong>存储在**<em>堆（heap）**</em>中的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3.什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3.什么是堆？什么是栈？它们之间有什么区别和联系？</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p><p>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</p><p>在操作系统中，内存被分为栈区和堆区。</p><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><h3 id="4-null和undefined的区别？"><a href="#4-null和undefined的区别？" class="headerlink" title="4.null和undefined的区别？"></a>4.null和undefined的区别？</h3><p>首先<strong>undefined</strong>和<strong>null</strong>都是<em>基本数据类型</em>，这两个基本数据类型分别都只有一个值，就是undefined和null。</p><p><strong>undefined</strong>代表的含义是<strong>未定义</strong>，<strong>null</strong>代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p><strong>undefined</strong>在js中不是一个保留字，这意味着我们可以使用<strong>undefined</strong>来作为一个变量名，但是这样做是非常危险的，它会影响我们对undefined的值的判断。但是我们可以通过一些方法获得安全的undefined值，比如说void 0。</p><p>当我们对两种类型使用<em>typeof</em>进行判断时，null类型化会返回<code>&quot;object&quot;</code>，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回<strong>true</strong>，使用三个等号会返回<strong>false</strong>。</p><h3 id="5-如何获取安全的undefined值？"><a href="#5-如何获取安全的undefined值？" class="headerlink" title="5.如何获取安全的undefined值？"></a>5.如何获取安全的undefined值？</h3><p>因为undefined是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响undefined的正常判断。</p><p>表达式<code>void ___</code>没有返回值，因此返回结果是undefined。void并不改变表达式的结果，只是让表达式不返回值。按惯例我们用void 0来获得undefined。</p><h3 id="6-prototype和-proto-的关系是什么？"><a href="#6-prototype和-proto-的关系是什么？" class="headerlink" title="6.prototype和_proto_的关系是什么？"></a>6.prototype和_proto_的关系是什么？</h3><ol><li><code>prototype</code>用于访问函数的原型对象</li><li><code>_proto_</code>用于访问对象实例的原型对象（或者使用<code>Object.getPrototypeOf()</code>）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test()</span><br><span class="line">test._prototype_ == Test.prototype   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>也就是说，函数拥有prototype属性，对象实例拥有<code>_proto_</code>属性，它们都是用来<strong>访问原型对象</strong>的。</p><p>函数有点特别，它<em>不仅是个函数，还是个对象</em>。所以它也有<code>_proto_</code>属性</p><h3 id="7-什么是闭包？"><a href="#7-什么是闭包？" class="headerlink" title="7.什么是闭包？"></a>7.什么是闭包？</h3><p><strong>闭包是指有权访问另一个函数作用域中的变量的函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = sayHi(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line">test()   <span class="comment">//Hi!xiaoming</span></span><br></pre></td></tr></table></figure><p>虽然sayHi函数已经执行完毕，但是其活动对象也不会被销毁，因为test函数仍然引用着sayHi函数中的变量name，这就是<strong>闭包</strong>。</p><p>（但也因为闭包引用着另一个函数的变量，导致另一个函数即使不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这是一个副作用）</p><h4 id="利用闭包实现私有属性"><a href="#利用闭包实现私有属性" class="headerlink" title="利用闭包实现私有属性"></a>利用闭包实现私有属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">getVal</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> value&#125;,</span><br><span class="line">      <span class="function"><span class="title">setVal</span>(<span class="params">val</span>)</span>&#123;value = val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>以上代码，实现了一个私有属性value，它只能用过<code>getVal()</code>来获取值，通过<code>setVal(val)</code>来设置值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript面试基础&quot;&gt;&lt;a href=&quot;#JavaScript面试基础&quot; class=&quot;headerlink&quot; title=&quot;JavaScript面试基础&quot;&gt;&lt;/a&gt;JavaScript面试基础&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-介绍js的基本数据类</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="面试" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端面试——CSS</title>
    <link href="http://example.com/2020/11/15/FE-interview-CSS/"/>
    <id>http://example.com/2020/11/15/FE-interview-CSS/</id>
    <published>2020-11-15T01:46:51.000Z</published>
    <updated>2020-11-27T01:49:09.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端面试——CSS"><a href="#前端面试——CSS" class="headerlink" title="前端面试——CSS"></a>前端面试——CSS</h2><h3 id="1-介绍一下标准CSS的盒子模型和低版本的IE盒子模型有什么不同？"><a href="#1-介绍一下标准CSS的盒子模型和低版本的IE盒子模型有什么不同？" class="headerlink" title="1.介绍一下标准CSS的盒子模型和低版本的IE盒子模型有什么不同？"></a>1.介绍一下标准CSS的盒子模型和低版本的IE盒子模型有什么不同？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;盒模型都是由四个部分组成的，分别是margin、border、padding和content。标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border，padding和content。一般来说，可以通过修改元素的box-sizing属性来改变元素的盒模型。</p><blockquote><p>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）<br>（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分。</p></blockquote><blockquote><p>IE盒模型和W3C标准盒模型的区别：</p><blockquote><p> （1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding；</p><p>（2）：IE盒模型：属性width，height包含<em>content</em>、<em>border</em>和<em>padding</em>，指的是 <strong>width=content+padding+border</strong>；</p></blockquote></blockquote><blockquote><p>&nbsp;&nbsp;在IE8+浏览器中使用哪个盒模型可以由<strong>box-sizing</strong>（CSS新增的属性）控制，默认值为<strong>content-box</strong>（W3C标准盒模型）;如果将<em>box-sizing</em>设为<em>border-box</em>则用的是<strong>IE盒模型</strong>。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有浏览器都会把盒模型解释为W3C盒模型。</p></blockquote><h3 id="2-CSS选择符有哪些？"><a href="#2-CSS选择符有哪些？" class="headerlink" title="2.CSS选择符有哪些？"></a>2.CSS选择符有哪些？</h3><p>（1）id选择符（<code>#myid</code>）</p><p>（2）类选择符（.myclassname）</p><p>（3）标签选择符</p><p>（4）后代选择符</p><p>（5）相邻后代选择器（子）选择器（ul&gt;li）</p><p>（6）兄弟选择器（li～a）</p><p>（7）相邻兄弟选择器（li+a）</p><p>（8）属性选择器</p><p>（9）伪类选择器</p><p>（10）伪元素选择器</p><p>（11）通配符选择器</p><h3 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="3. ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"></a>3. ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h3><p>在css3中使用<em>单冒号</em>来表示<strong>伪类</strong>，用<em>双冒号</em>来表示<strong>伪元素</strong>。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。</p><p>伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after，before等。</p><blockquote><p>单冒号( ：)用于CSS3伪类，双冒号(::)用于CSS3伪元素（伪元素由双冒号和伪元素名称组成）。双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</p><p>想让插入的内容出现在其他内容前，使用::before，否则，使用::after；</p><p>在代码顺序上,::after生成的内容也比::before生成的内容靠后</p><p>如果按堆栈视角，::after生成的内容会在::before生成的内容上。</p></blockquote><h3 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4.伪类与伪元素的区别"></a>4.伪类与伪元素的区别</h3><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如：一句话中的第一个字母，或者是列表中的第一个元素。</p><p><strong>伪类</strong>用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说：当用户<em>悬停</em>在指定的元素时，我们可以通过 <code>:hover</code>来描述这个元素的状态。</p><p><strong>伪元素</strong>用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过<code>::before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><p>有时你会发现伪元素使用了两个冒号（<code>::</code>）而不是一个冒号（<code>:</code>）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（<code>::</code>）而不是（<code>:</code>），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</p><p>*[参考资料]:<a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/">总结伪类与伪元素</a></p><h3 id="5-CSS中哪些属性可以继承？"><a href="#5-CSS中哪些属性可以继承？" class="headerlink" title="5.CSS中哪些属性可以继承？"></a>5.CSS中哪些属性可以继承？</h3><p>每个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用元素的同属性的值来作为自己的值。</p><p>一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些<em>布局属性</em>，<em>列表属性</em>如list-style等。还有<em>光标属性</em>cursor，<em>元素可见性</em>visibility。</p><p>当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</p><p>*[参考资料]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance">继承属性</a>，<a href="https://www.jianshu.com/p/34044e3c9317">CSS有哪些属性可以继承</a></p><h2 id="Front-end-basic-knowledge"><a href="#Front-end-basic-knowledge" class="headerlink" title="Front-end-basic-knowledge"></a>Front-end-basic-knowledge</h2><h3 id="1-CSS选择器的优先级是如何计算的？"><a href="#1-CSS选择器的优先级是如何计算的？" class="headerlink" title="1.CSS选择器的优先级是如何计算的？"></a>1.CSS选择器的优先级是如何计算的？</h3><p>浏览器通过优先级规则，判断元素展示哪些样式。优先级通过4个维度指标确定，假设以a，b，c，d分别代表</p><ol><li>a表示是否使用内联样式，如果使用，a为1，否则为0</li><li>b表示ID选择器的数量</li><li>c表示类选择器，属性选择器和伪类选择器数量之和</li><li>d表示标签（类型）选择器和伪元素选择器之和</li></ol><p>比较方法：abcd每个值分开比较。abcd权重从左到右，依次减小。判断优先级时，从左到右一一比较。所以如果b的值不同，那么c和d不管多大，都不会对结果产生影响。比如0，1，0，0的优先级高于0，0，10，10</p><p>当出现优先级相等的情况时，最晚出现的样式规则会被采纳，或者最后出现的（在文件底部的）样式优先级更高，因此会被采纳。</p><h3 id="2-重置-resetting-CSS和标准化-normalizing-CSS的区别是什么？会选择哪种方式，为什么？"><a href="#2-重置-resetting-CSS和标准化-normalizing-CSS的区别是什么？会选择哪种方式，为什么？" class="headerlink" title="2.重置(resetting)CSS和标准化(normalizing)CSS的区别是什么？会选择哪种方式，为什么？"></a>2.重置(resetting)CSS和标准化(normalizing)CSS的区别是什么？会选择哪种方式，为什么？</h3><ul><li><strong>重置</strong>：意味着除去所有的浏览器默认样式。对于页面所有的元素，像margin、padding、font-size这些样式会全部重置成一样。必须重新定义各种元素的样式。</li><li><strong>标准化</strong>：标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li></ul><p>（当需要实现非常个性化的网页时，可以选择重置样式，这样可以写很多自定义的样式来满足设计需求，这时候就不再需要标准化的默认样式）</p><h3 id="3-阐述Float定位的工作原理。"><a href="#3-阐述Float定位的工作原理。" class="headerlink" title="3.阐述Float定位的工作原理。"></a>3.阐述Float定位的工作原理。</h3><p>浮动（float）是CSS定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位。（这里与绝对定位不同，绝对定位会完全从文档流中脱离）</p><p>CSS的clear属性通过使用left、right、both，让该元素向下移动（清除浮动）到浮动元素下面。</p><p>如果父元素只包含浮动元素，那么该父元素的高度将塌缩为0。可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。</p><p>还有一种hack方法，是自定义一个<code>.clearfix</code>类，利用伪元素选择器<code>::after</code>清除浮动。还有一些方法，如添加空的<code>&lt;div&gt;&lt;/div&gt;</code>和设置浮动元素父元素的<code>overflow</code>属性。与这些方法不同的是，<code>clearfix</code>方法，只需给父元素添加一个类：如</p><p><code>.clearfix:after&#123;content:&#39;&#39;;display:block;clear:both;&#125;</code></p><p>值得一提的是，把父元素属性设置为<code>overflow:auto</code>或<code>overflow:hidden</code>，会使其内部的子元素形成块格式化上下文，并且父元素会扩张自己，使其能够包围它的子元素。</p><h3 id="4-说说z-index属性，它是如何形成层叠上写文-stacking-context-的。"><a href="#4-说说z-index属性，它是如何形成层叠上写文-stacking-context-的。" class="headerlink" title="4.说说z-index属性，它是如何形成层叠上写文(stacking context)的。"></a>4.说说z-index属性，它是如何形成层叠上写文(stacking context)的。</h3><p>CSS中的<code>z-index</code>属性控制重叠元素的垂直叠加顺序。<code>z-index</code>只能影响<code>position != static</code>的元素。</p><p>没有定义z-index的值时，元素按照它们出现在DOM中的顺序堆叠，<em>层级越低，出现位置越靠上</em>。非静态定位的元素（及其子元素）将始终覆盖静态定位(static)的元素，而不管HTML层次结构如何。</p><p>层叠上下文是包含一组图层的元素。在一组层叠上下文中，其子元素的z-index的值是相对于该父元素而不是document root设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素B位于元素A之上，则即使元素A的子元素C具有比元素B更高的z-index值，元素C永远不会在元素B之上。</p><p>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数CSS属性会触发一个新的层叠上下文，例如<code>opacity&lt;1</code>,filter不是none，transform不是none。</p><h3 id="5-关于伪类LVHA的解释？"><a href="#5-关于伪类LVHA的解释？" class="headerlink" title="5.关于伪类LVHA的解释？"></a>5.关于伪类LVHA的解释？</h3><p>LVHA分别对应a标签的<strong>四种</strong>状态，<em>链接访问前，链接访问后，鼠标滑过，激活</em>分别对应<code>:link,:visited,:hover,:active</code>；</p><p>（LoVe HAte）</p><p>当链接未访问过时：</p><p>（1）当鼠标滑过a链接时，满足<code>:link</code>和<code>:hover</code>两种状态，要改变a标签的颜色，就必须将<code>:hover</code>伪类在<code>:link</code>伪类后声明；</p><p>（2）当鼠标点击激活a链接时，同时满足<code>:link,:hover,:active</code>三种状态，要显示a标签激活时的样式（:active)，必须将<code>:active</code>声明放到<code>:link</code>和<code>:hover</code>之后。因此得出<strong>LVHA</strong>这个顺序。</p><p>当链接访问过时，情况基本同上，只不过需要将<code>:link</code>换成<code>:visited</code></p><p>这个顺序可以改变的。但是！**<em>只有**</em><code>:link</code>和<code>:visited</code>可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖问题。</p><h3 id="6-display有哪些值？说明他们的作用。"><a href="#6-display有哪些值？说明他们的作用。" class="headerlink" title="6.display有哪些值？说明他们的作用。"></a>6.display有哪些值？说明他们的作用。</h3><ul><li>block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none     元素不显示，并从文档流中移除</li><li>inline     行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示</li><li>inline-block     默认宽度为内容宽度，可以设置宽高，同行显示</li><li>list-item    像块类型元素一样显示，并添加样式列表标记</li><li>table    此元素会作为块级表格来显示</li><li>inherit    规定应该从父元素继承display属性的值。</li></ul><h3 id="7-position的值relative和absolute定位原点是？"><a href="#7-position的值relative和absolute定位原点是？" class="headerlink" title="7.position的值relative和absolute定位原点是？"></a>7.position的值relative和absolute定位原点是？</h3><p>relative定位的元素，是相对于元素本身的正常位置来进行定位的。</p><p>absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话可以理解为：首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端面试——CSS&quot;&gt;&lt;a href=&quot;#前端面试——CSS&quot; class=&quot;headerlink&quot; title=&quot;前端面试——CSS&quot;&gt;&lt;/a&gt;前端面试——CSS&lt;/h2&gt;&lt;h3 id=&quot;1-介绍一下标准CSS的盒子模型和低版本的IE盒子模型有什么不同？&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="面试" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端基础——HTML</title>
    <link href="http://example.com/2020/11/12/FE-interview-HTML/"/>
    <id>http://example.com/2020/11/12/FE-interview-HTML/</id>
    <published>2020-11-12T08:25:38.000Z</published>
    <updated>2020-11-23T12:40:42.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML基础面试"><a href="#HTML基础面试" class="headerlink" title="HTML基础面试"></a>HTML基础面试</h2><h3 id="1、-lt-img-gt-的-title-和-alt-有什么区别："><a href="#1、-lt-img-gt-的-title-和-alt-有什么区别：" class="headerlink" title="1、&lt;img&gt;的 title 和 alt 有什么区别："></a>1、<code>&lt;img&gt;</code>的 title 和 alt 有什么区别：</h3><ul><li>title是 global attributes 之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。</li><li>alt是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ul><h3 id="2、doctype-是什么-举例常见-doctype-及特点"><a href="#2、doctype-是什么-举例常见-doctype-及特点" class="headerlink" title="2、doctype 是什么,举例常见 doctype 及特点"></a>2、doctype 是什么,举例常见 doctype 及特点</h3><ul><li><!doctype> 声明必须处于HTML文档的头部，在<code>&lt;html&gt;&lt;/html&gt;</code>标签之前，HTML5中不区分大小写</li><li> <!doctype> 声明不是一个HTML标签，是一个用于告诉浏览器当前HTML版本的指令</li><li> 现代浏览器的html布局引擎通过检查 doctype 决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</li><li> 在HTML4.01中 &lt;!doctype&gt; 声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</li><li> HTML5不基于SGML，所以不用指定DTD</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML基础面试&quot;&gt;&lt;a href=&quot;#HTML基础面试&quot; class=&quot;headerlink&quot; title=&quot;HTML基础面试&quot;&gt;&lt;/a&gt;HTML基础面试&lt;/h2&gt;&lt;h3 id=&quot;1、-lt-img-gt-的-title-和-alt-有什么区别：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="面试" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>简述CSS3中的Flex box</title>
    <link href="http://example.com/2020/11/11/desFlex/"/>
    <id>http://example.com/2020/11/11/desFlex/</id>
    <published>2020-11-11T02:59:09.000Z</published>
    <updated>2020-11-28T11:35:01.938Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲CSS3的Flex box以及它的一些适用场景。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>Flex是FlexibleBox的缩写，意为“弹性布局”，它是CSS3新增的一种布局方式，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局，包括行内元素也可以。但是要注意：<em>设置为Flex布局之后，子元素的float，clear和vertical-align属性将会失效</em></p><p>采用Flex布局的元素，称为<strong>Flex容器</strong>（flex container），简称容器，它的<strong>所有子元素</strong>自动成为容器成员，称为<strong>Flex项目</strong>（flex item），简称项目。</p><p>容器还默认存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)，项目默认沿主轴排列。</p><h3 id="2-设置在容器上的6个属性"><a href="#2-设置在容器上的6个属性" class="headerlink" title="2.设置在容器上的6个属性"></a>2.设置在容器上的6个属性</h3><ul><li>flex-direction：决定主轴的方向，即项目的排列方向。</li><li>flex-wrap：定义了如果一条轴线排不下，如何换行。</li><li>flex-flow：flex-direction和flex-wrap属性的简写形式，默认值为：row nowrap。</li><li>justify-content：定义了项目在主轴上的对齐方式。</li><li>align-items：定义了项目在交叉轴上的对齐方式。</li><li>align-content：定义了多根轴线的对齐方式。如果项目只有一根线，该属性不起作用。</li></ul><h3 id="3-设置在项目上的6个属性"><a href="#3-设置在项目上的6个属性" class="headerlink" title="3.设置在项目上的6个属性"></a>3.设置在项目上的6个属性</h3><ul><li>order：定义了项目的排列顺序。数值越小，排列越靠前，默认为0.</li><li>flex-grow：定义项目的放大比例，默认为0，表示如果存在剩余空间，也不放大。</li><li>flex-shrink：定义了项目的缩小比例，默认为1，表示如果空间不足，将缩小该项目。</li><li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余的空间。默认为auto，即项目本来的大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>flex是CSS3中新增的一种布局方式，可以通过<code>display:flex</code>将一个容器设置为flex布局，它的所有子元素都会成为它的项目。</p><p>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。可以用<code>flex-direction</code>来指定主轴的方向，可以用<code>justify-content</code>来指定元素在主轴上的排列方式，使用<code>align-items</code>来指定元素在交叉轴上的排列方式，可以使用<code>flex-wrap</code>来规定当一行排列不下时的换行方式。</p><p>对于容器中的项目，可以使用<code>order</code>来指定项目的排列顺序，用<code>flex-grow</code>来指定当排列空间有剩余的时候，项目的放大比例；用<code>flex-shrink</code>来指定当排列空间不足时，项目的缩小比例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要讲CSS3的Flex box以及它的一些适用场景。&lt;/p&gt;
&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.定义&quot;&gt;&lt;/a&gt;1.定义&lt;/h3&gt;&lt;p&gt;Flex是FlexibleBox的缩写，意为“弹性</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/10/30/hello-world/"/>
    <id>http://example.com/2020/10/30/hello-world/</id>
    <published>2020-10-30T06:54:25.207Z</published>
    <updated>2020-10-30T06:54:25.207Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解this</title>
    <link href="http://example.com/2020/09/23/this/"/>
    <id>http://example.com/2020/09/23/this/</id>
    <published>2020-09-23T06:03:21.000Z</published>
    <updated>2020-11-23T12:37:59.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this的原理"><a href="#this的原理" class="headerlink" title="this的原理"></a>this的原理</h2><h3 id="一、问题的由来"><a href="#一、问题的由来" class="headerlink" title="一、问题的由来"></a>一、问题的由来</h3><p>学懂JavaScript语言，一个标志就是理解下面两种写法，可能有不一样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上面代码中，虽然obj.foo和foo指向同一个函数，但是执行结果可能不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar) &#125;,</span><br><span class="line">  bar: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = obj.foo;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// 1</span></span><br><span class="line">foo() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这种差异的原因，就在于函数体内部使用了<strong>this</strong>关键字。很多教科书说，this指的是函数运行时所在的环境。对与<code>obj.foo()</code>来说，foo运行在obj环境，所以this指向obj；对于foo()来说，foo运行在<strong>全局环境</strong>，所以this指向全局环境。所以，两种运行结果不一样。</p><p>这种解释没错，但是教科书往往不告诉你，为什么会这样？也就是说，函数的运行环境到底是怎么决定的？举例来说，为什么<code>obj.foo()</code>就是在<code>obj</code>环境执行，而一旦<code>var foo = obj.foo</code>，<code>foo()</code>就变成在全局环境执行？</p><p>本文就来解释 JavaScript 这样处理的原理。理解了这一点，你就会彻底理解<code>this</code>的作用。</p><h3 id="二、内存的数据结构"><a href="#二、内存的数据结构" class="headerlink" title="二、内存的数据结构"></a>二、内存的数据结构</h3><p>JavaScript 语言之所以有<code>this</code>的设计，跟内存里面的数据结构有关系。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061801.png" alt="img"></p><p>也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p><p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061802.png" alt="img"></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p><h3 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h3><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></blockquote><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061803.png" alt="img"></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">f</span>: f &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f()</span><br></pre></td></tr></table></figure></blockquote><h3 id="四、环境变量"><a href="#四、环境变量" class="headerlink" title="四、环境变量"></a>四、环境变量</h3><p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p><p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061804.png" alt="img"></p><p>在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061805.png" alt="img"></p><p>回到本文开头提出的问题，<code>obj.foo()</code>是通过<code>obj</code>找到<code>foo</code>，所以就是在<code>obj</code>环境执行。一旦<code>var foo = obj.foo</code>，变量<code>foo</code>就直接指向函数本身，所以<code>foo()</code>就变成在全局环境执行。</p><p>（完）</p><blockquote><p>以上内容来自<strong>阮一峰</strong>博客</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;this的原理&quot;&gt;&lt;a href=&quot;#this的原理&quot; class=&quot;headerlink&quot; title=&quot;this的原理&quot;&gt;&lt;/a&gt;this的原理&lt;/h2&gt;&lt;h3 id=&quot;一、问题的由来&quot;&gt;&lt;a href=&quot;#一、问题的由来&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="this" scheme="http://example.com/tags/this/"/>
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
</feed>
